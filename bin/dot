#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT
  tput cnorm # enable cursor
  # script cleanup here
}

command_name=$(basename "${BASH_SOURCE[0]}")
script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
STOW_DIR="$DOTFILES"
# Directories to ignore when linking
IGNORE_LIST=("bin" "applescripts" "resources")

if [[ -f "$DOTFILES/bin/lib/common.sh" ]]; then
  source "$DOTFILES/bin/lib/common.sh"
else
  echo "Error: Unable to source common.sh"
  exit 1
fi

find_commands() {
  IFS=: read -ra path_dirs <<<"$PATH"
  for dir in "${path_dirs[@]}"; do
    # skip if the directory doesn't exist or isn't readable
    [[ ! -d "$dir" ]] && continue
    for cmd in "$dir"/dot-*; do
      [[ -f "$cmd" && -x "$cmd" ]] || continue
      basename "$cmd" | sed 's/^dot-//'
    done
  done | sort -u
}

usage() {
  cat <<EOF
  $(fmt_key "Usage:") $(fmt_cmd "$command_name") $(fmt_value "<command> [subcommand] [options]")

Dotfiles management script.

$(fmt_key "Available Commands:")
    help                      Show this help message
    link                      Manage stow symlinks
        all                   Link all
        <pkg>                 Link a specific package
    unlink                    Manage stow symlinks
        all                   Unlink all
        <pkg>                 Ulnlink a specific package
EOF

  echo -e "\nExternal commands:"

  find_commands | while read -r cmd; do
    # Get the description from the script if available
    description=$(grep "^# Description:" "$(which "dot-$cmd")" 2>/dev/null | cut -d: -f2- | sed 's/^[[:space:]]*//' || echo "No description available")
    printf "    $(fmt_cmd "%-12s") %s\n" "$cmd" "$description"
  done
}

cmd_stow() {
  local operation="$1"
  local stow_flags="$2"
  shift 2

  local subcmd=""
  local verbose=false
  local target="$HOME"

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -v | --verbose)
      verbose=true
      shift
      ;;
    -t | --target)
      if [[ -n "${2:-}" ]]; then
        target="$2"
        shift 2
      else
        log_error "Missing target directory"
        exit 1
      fi
      ;;
    -h | --help)
      cat <<EOF
Usage: $command_name ${operation} [options] <package>

Options:
    -v, --verbose    Show detailed output
    -t, --target     Specify target directory (default: $HOME)
    -h, --help       Show this help message
    <package>        Package to link (or \"all\" for all packages)
EOF
      exit
      ;;
    *)
      if [[ -z "$subcmd" ]]; then
        subcmd="$1"
      else
        log_error "Unknown argument: $1"
        exit 1
      fi
      shift
      ;;
    esac
  done

  [[ -z "$subcmd" ]] && subcmd="all"
  local stow_opts=($stow_flags -d "$STOW_DIR" -t "$target")
  [[ "$verbose" == true ]] && stow_opts+=(--verbose)

  case "$subcmd" in
  all)
    log_info "${operation}ing all packages to $target..."
    for pkg in "$STOW_DIR"/*; do
      if [ -d "$pkg" ]; then
        pkg_name=$(basename "$pkg")

        skip=false
        for ignored in "${IGNORE_LIST[@]}"; do
          if [ "$pkg_name" == "$ignored" ]; then
            skip=true
            break
          fi
        done
        [[ "$skip" == true ]] && continue

        if stow "${stow_opts[@]}" "$pkg_name" 2>/dev/null; then
          log_success "${operation}ed $pkg_name"
        else
          log_warning "Failed to ${operation} $pkg_name"
        fi
      fi
    done
    ;;
  *)
    if [ -d "$STOW_DIR/$subcmd" ]; then
      log_info "Linking $subcmd to $target..."
      if stow "${stow_opts[@]}" "$subcmd" 2>/dev/null; then
        log_success "${operation}ed $subcmd"
      else
        log_warning "Failed to ${operation} $subcmd"
      fi
    else
      log_error "Package $subcmd not found in $STOW_DIR"
      exit 1
    fi
    ;;
  esac
}

cmd_link() {
  cmd_stow "link" "" "$@"
}

cmd_unlink() {
  cmd_stow "unlink" "-D" "$@"
}

main() {
  if [ $# -lt 1 ]; then
    usage
    exit 0
  fi

  cmd="$1"
  shift || true
  subcmd="${1:-all}"

  case "$cmd" in
  help)
    usage
    ;;
  link)
    cmd_link "$subcmd"
    ;;
  unlink)
    cmd_unlink "$subcmd"
    ;;
  *)
    if command -v "dot-$cmd" >/dev/null 2>&1; then
      "dot-$cmd" "$@"
    else
      log_error "Unknown command: $cmd"
      usage
      exit 1
    fi
    ;;
  esac
}

main "$@"
