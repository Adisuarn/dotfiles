#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT
  tput cnorm # enable cursor
  # script cleanup here
}

command_name=$(basename "${BASH_SOURCE[0]}")
script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
STOW_DIR="$DOTFILES"
# Directories to ignore when linking
IGNORE_LIST=("bin" "applescripts" "resources")

if [[ -f "$DOTFILES/bin/lib/common.sh" ]]; then
  source "$DOTFILES/bin/lib/common.sh"
else
  echo "Error: Unable to source common.sh"
  exit 1
fi

find_commands() {
  IFS=: read -ra path_dirs <<<"$PATH"
  for dir in "${path_dirs[@]}"; do
    # skip if the directory doesn't exist or isn't readable
    [[ ! -d "$dir" ]] && continue
    for cmd in "$dir"/dot-*; do
      [[ -f "$cmd" && -x "$cmd" ]] || continue
      basename "$cmd" | sed 's/^dot-//'
    done
  done | sort -u
}

usage() {
  cat <<EOF
  $(fmt_key "Usage:") $(fmt_cmd "$command_name") $(fmt_value "<command> [subcommand] [options]")

Dotfiles management script.

$(fmt_key "Available Commands:")
    help                          Show this help message
    backup                        Backup dotfiles
        -d, --directory <dir>   Backup directory (default: ~/dotfiles-backup)
    link                          Manage stow symlinks
        all                       Link all
        <pkg>                     Link a specific package
    unlink                        Manage stow symlinks
        all                       Unlink all
        <pkg>                     Unlink a specific package
EOF

  echo -e "\nExternal commands:"

  find_commands | while read -r cmd; do
    # Get the description from the script if available
    description=$(grep "^# Description:" "$(which "dot-$cmd")" 2>/dev/null | cut -d: -f2- | sed 's/^[[:space:]]*//' || echo "No description available")
    printf "    $(fmt_cmd "%-12s") %s\n" "$cmd" "$description"
  done
}

cmd_backup() {
  local backup_dir="$HOME/dotfiles-backup"
  local verbose=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -d | --directory)
      if [[ -n "${2:-}" ]]; then
        backup_dir="$2"
        shift 2
      else
        log_error "Missing backup directory"
        exit 1
      fi
      ;;
    -v | --verbose)
      verbose=true
      shift
      ;;
    *)
      log_error "Unknown argument: $1"
      exit 1
      ;;
    esac
  done

  # Expand ~ in backup_dir
  backup_dir="${backup_dir/#\~/$HOME}"

  local timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_path="${backup_dir}/dotfiles_backup_${timestamp}"

  if [[ ! -d "$backup_path" ]]; then
    mkdir -p "$backup_path" || {
      log_error "Failed to create backup directory: $backup_path"
      exit 1
    }
  fi

  log_info "Creating backup in: $backup_path"

  files_to_backup=(
    ".zshrc"
    ".zshenv"
    ".zprofile"
    ".zsh_aliases"
    ".zsh_functions"
    ".zsh_prompt"
    ".config/aerospace"
    ".config/git"
    ".config/ghostty"
    ".config/karabiner"
    ".config/kitty"
    ".config/lazygit"
    ".config/nvim"
    ".config/ripgrep"
    ".config/tmux"
    ".config/wezterm"
    ".config/zsh"
  )

  for src in "${files_to_backup[@]}"; do
    src_path="${HOME}/${src}"
    if [[ -e "$src_path" ]]; then
      local dest="${backup_path}/${src}"
      mkdir -p "$(dirname "$dest")"

      if [[ -d "$src_path" ]]; then
        cp -R "$src_path" "$(dirname "$dest")" || {
          log_warning "Failed to copy directory $src_path"
          continue
        }
        [[ "$verbose" == true ]] && log_info "Copied directory: $src_path"
      else
        cp "$src_path" "$dest" || {
          log_warning "Failed to copy file $src_path"
          continue
        }
        [[ "$verbose" == true ]] && log_info "Copied file: $src_path"
      fi
    else
      log_warning "File not found: $src_path"
    fi
  done

  log_success "Backup created successfully at $backup_path"
}

cmd_stow() {
  local operation="$1"
  local stow_flags="$2"
  shift 2

  local subcmd=""
  local verbose=false
  local target="$HOME"

  while [[ $# -gt 0 ]]; do
    case "$1" in
    -v | --verbose)
      verbose=true
      shift
      ;;
    -t | --target)
      if [[ -n "${2:-}" ]]; then
        target="$2"
        shift 2
      else
        log_error "Missing target directory"
        exit 1
      fi
      ;;
    -h | --help)
      cat <<EOF
Usage: $command_name ${operation} [options] <package>

Options:
    -v, --verbose    Show detailed output
    -t, --target     Specify target directory (default: $HOME)
    -h, --help       Show this help message
    <package>        Package to link (or \"all\" for all packages)
EOF
      exit
      ;;
    *)
      if [[ -z "$subcmd" ]]; then
        subcmd="$1"
      else
        log_error "Unknown argument: $1"
        exit 1
      fi
      shift
      ;;
    esac
  done

  [[ -z "$subcmd" ]] && subcmd="all"
  local stow_opts=($stow_flags -d "$STOW_DIR" -t "$target")
  [[ "$verbose" == true ]] && stow_opts+=(--verbose)

  case "$subcmd" in
  all)
    log_info "${operation}ing all packages to $target..."
    for pkg in "$STOW_DIR"/*; do
      if [ -d "$pkg" ]; then
        pkg_name=$(basename "$pkg")

        skip=false
        for ignored in "${IGNORE_LIST[@]}"; do
          if [ "$pkg_name" == "$ignored" ]; then
            skip=true
            break
          fi
        done
        [[ "$skip" == true ]] && continue

        if stow "${stow_opts[@]}" "$pkg_name" 2>/dev/null; then
          log_success "${operation}ed $pkg_name"
        else
          log_warning "Failed to ${operation} $pkg_name"
        fi
      fi
    done
    ;;
  *)
    if [ -d "$STOW_DIR/$subcmd" ]; then
      log_info "Linking $subcmd to $target..."
      if stow "${stow_opts[@]}" "$subcmd" 2>/dev/null; then
        log_success "${operation}ed $subcmd"
      else
        log_warning "Failed to ${operation} $subcmd"
      fi
    else
      log_error "Package $subcmd not found in $STOW_DIR"
      exit 1
    fi
    ;;
  esac
}

cmd_link() {
  cmd_stow "link" "" "$@"
}

cmd_unlink() {
  cmd_stow "unlink" "-D" "$@"
}

main() {
  if [ $# -lt 1 ]; then
    usage
    exit 0
  fi

  cmd="$1"
  shift || true
  subcmd="${1:-all}"

  case "$cmd" in
  help)
    usage
    ;;
  backup)
    cmd_backup "$@"
    ;;
  link)
    cmd_link "$subcmd"
    ;;
  unlink)
    cmd_unlink "$subcmd"
    ;;
  *)
    if command -v "dot-$cmd" >/dev/null 2>&1; then
      "dot-$cmd" "$@"
    else
      log_error "Unknown command: $cmd"
      usage
      exit 1
    fi
    ;;
  esac
}

main "$@"
